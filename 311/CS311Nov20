CS 311 Notes @ 11/20/2012

Example: PDA for {x \element {a,b}* | x has twice # of a's than b's }

	e = empty string

	e
	baa
	aab
	aba
	bbaaaa
	babaaa
	
	N_0(x) = N_1(x)
	1st input 0...

  1st input = 'b'
    push 2 B's for 'b'
    pop 1 B for each 'a'
  1st input = 'a'
    push 1 A for each 'a'
    pop  2 As for each 'b'

  D = \delta
  e = \epsilon

  NOTE , can never have 2 symbols in transition, can only see top of stack in D(state, consume, top) 

  D(P0, e, Z0) = (P0, e) 
  D(P0, b, Z0) = (P0, BBZ0)
  D(P0, b, B)  = (P0, BBB)
  D(P0, a, B)  = (P0, e) 
  D(P0, a, Z0) = (P0, AZ0) 
  D(P0, a, A)  = (P0, AA)
  D(P0, b, A)  = (P1, e) 
  D(P0, e, A)  = (P0, e) //come back to p0, allows pop() of 2 As
  D(P1, e, Z0) = (P0, BZ0) // push 1 b, for cases a->b
  
  Equivalece of CFGs and PDAs
    G <--> (\exists)M
    (exists)G <--> m      

    $\forall$CFG G ,$\exists$ a PDA M
    such that L(G) = Le(M)

  Algorithm:
      E  = \sigma 
    Let G = (N, E, P, S) 
    Construct M = ({q}, E, n \union E, D, q, S, {\theta} where D:
      1) (q, \alpha) \element D(q, e, A) if A-> alpha \element P
      2) D(q,a,a) = (q,e) \forall a \element E
   
EXAMPLE: Given a CFG G = ({E,T,F}, {(),a,+,*}, P, E) where p is defined:
        E -> E + T | T
        T -> T * F | F
        F -> (E) | a 

  Construct equivalent PDA M =
     ( {q}, {(,),a,+,*}, {E,T,F,(,),a,+,*}, D, q, E, \theta)

  D(q, e, E) = {(q,E+T), (q,T)}
  D(q, e, T) = {(q,T*F)(q,F)}
  D(q, e, F) = (q,(E)), (q,a)} //by rule 1

  D(q,(, ( ) = (q,e)
  D(q,), ) ) = (q,e)
  D(q,a,a)   = (q,e)
  D(q,+,+)   = (q,e)
  D(q,*,*)   = (q,e) // by rule 2 (essentially pop all terminals)  
  
  EXAMPLE: a*a+a \element L(G) ?
        E
      / | \
     E  +  T
     |     | 
     T     F
           \ 
            a
 etc...constrcut tree, shows it's in the language...

 (see notes for stack drawing) 

DEFINITION: A PDA M  = (S, E< P, D, Po, Zo, F) is deterministic if 
  \forall P \elementS, \forall Z \element GAMMA
  
  1) D(P,e,Z) = \theta  and \forall a \element \sigma[ |D(p,a,z) <= |], and
  2) \forall a \element \sigma [ D(P,a,Z) = \theta] and |D(p,e,Z) | <= |.

    DPDA

  How do you assert that a PDA is deterministic?
 
    - For 2nd example (ww^R) it's clearly non-deterministic because more than 1 tranistion. 
    - For {a^n b^2n } we have an input move and e move defined for P0, therefore non-deterministic
    - For {a^i,b^j | i > j} 
      NPDA because there p0-e-A and p0-a-Z0 


DEFINE: A language L is deterministic CFL (DCFL) 
  if it can be created by a DPDA

  CFL: Language generated by context free grammar (CFG) or can be recognized by a PDA
  
  DCFL - L can be accepted by a DPDA
 
    DFSA = nfsa, regular
  
    EXAMPLE: if L = {ww^R} we know it's a CFL, but NOT a deterministic CFL

NOTE: Should be able to do first 3 problems of homework at this point


NON-CFL: 
=======

  EXAMPLE: L1 = {a^n b^n c^n | n>= 0} CFL?
  
    D(P0, e, Z0) = (P0, e)
    D(P0, a, Z0) = (P0, AAZ0)
    D(P0, a, A)  = (P0, AAA) 
    D(P0, b, A)  = (P1, e)
    D(P1, b, A)  = (P1, e)
    D(P1, c, A)  = (P2, e)
    D(P2, c, A)  = (P2, e)
    D(P2, e, Z0) = (P2, e) 

    ^ Doesn't work, accepts aabbbc unfortunately

    It's not a CFL as proved by pumping lemma (not in scope of this class)

    Intuitive Explaination:
      Step 1: to store n, the # of a's, by pushing symbols in top of stack
      Step 2: to check whether there are equivalen # of b's, we retrive n
              by popping symbols off the stack (n is erased) 

      Step 3: No way to check if |c| = |b| = |a| because n dissappears
     
      OBSERVATOIN:
        1. You can use the stack of PDA to store any arbritary number
           no upper limit (continuous push)
        2. However, the number can not be retrived more than once
        
        Based on this L = {a^i b^i c^n | n>= i} not a CFL
        
  EXAMPLE: L2 = {a^m b^n c^n d^m | m,n >= 0} CFL?
    Yes, only doing 1 comparison at a time

  EXAMPLE: L3 = {a^m b^n c^m d^n | m,n, >= 0} CFL?
    No, can't keep track of first m because it won't be on top of the stack

  Observation:
    1. You can save more than 1 number
    2. However numbers have to be returned in reverse order

 
EXERCISES:
  1. {a^n b^n c^i | n != i}
    No, n is destroyed after checking b
  2. {a^i b^j c^k | i!=j}
    Yes, i compare j, don't care about k 
  3. (a^mb^n | m<= n <= 2m} 
    Yes? 1 comparison 
    
      S -> aSb | aSbb | e

