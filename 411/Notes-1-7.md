#CS 411 Compilers and Interpreters
## 1/7/2013

##Course Description:
- Chapters 1-6
- CS 311 (Languages and Automata) 


## Lecture Notes:
### What is a compiler?

  source program->compiler(a program with input and output) -> syntactically
  and semantically correct -> object code

  if compiler NOT syntatically correct -> error message
  
### Source Program:
- Lexical analysis
- Syntax Analysis
- Semantic Analysis
- Intermediate Code Generation
- Code optimization
- Assembly -> Object Code

####Lexical Analyzer (Or Scanner)
- Scan through input file, chop input into tokens
- Save identifiers into symbol table

  Tokens = {id, assignop, addop, mulop...num}  
  IDENTIFIER_regex = [_a-zA-Z][_a-zA-Z0-9]*
  UNSIGNED_regex = [1-9][0-9]* | 0 

Output: Tokens

####Syntax Analyzer(parser)
- Build up the parse tree (parse tree = graphical representation of CFG)
Example:
  CFG:
  <AS>  -> id assignop <EXP>
  <EXP> -> <EXP> + <EXP>
        -> <EXP> * <EXP>
        id |
        num

(Draw a derivation tree for "position = initial + rate * 60")

Output: Parse Tree

####Semantic Analyzer
- Define/Determine the meaning of the parse tree
- Perform TYPE checking
Example: if rate is a real number:
  60 -> 60.0

Output: Annotated Parse Tree

####Code Generator
- Generate 3 addr instructions from annotated parse tree

  temp1 = intToReal(60)
  temp2 = id3 * temp1
  temp3 = id2 + temp2
  id1 = temp3

Output: 3 Address Instructions

####Code Optimization
- Generate efficient code in terms of 
 - Storage requirements
 - Computation Time

  temp1 = id3 * 60.0
  id1 = id2 + temp1

1. Local improvement
 - Constant folding
  x = 10 * 2 [folded to]=> x = 20
 - Strength Reduction
  x * 2 [replaced]=> x + x
  x **2 [replaced]=> x * x

2. Global Improvement 
- Data flow analysis for loop optimization

###Table Management
- Related to above 6 points:
 1. Lexical Analysis
 2. Syntax Analysis
 3. Semantic Analysis
 4. Intermediate Code Generation
 5. Code Optimization
 6. Assembly

- Also related to:
 - Error detection and recovering

###Related Courses
- CS 311: Formal Language Theory
- CS 408: Programing Languages and Design
- CS 480: Program Verification

###Terms
####Front-end vs Back-end
- Front end: include those phases that depend on the source program (independent of the target machine)
  - Lexical, syntax, semantic analysis
- Back end: include those phases that depend on the target program
  - Intermediate code generation, code optimization, assembly

####X-Pass Compiler 
- Pass compiler: Each pass consistes of reading an input filer and writing an output file 
  - Passes consist of a group of phases

####Compiler vs Translator
A set of pairs of strings:

  A->[Translator]->B

- Compiler: a translation in which the pairs are (source program and object code)

###Complete View of Language Processing System

-Source Code
  -[Compiler]
  -Object Code
  -[Linker/Loader]
  -Executable Code

###Definition of Grammar
A grammar is a 4 tuple G = (N,E,P,S) where:
  1. N is a finite set of non-terminals
  2. E ...................terminals
  3. (N U E)* N (N U E)* x (N U E)*
  4. S \element N the initial nonterminal

  Cartesian Product: 
   
     A x B = {(a,b) | a\elementA , b\elementB}
     \alpha -> (generates) \beta 

#### Example G = ( {E,T,F}, {(,),+,*,a}, P, E) where P:

     E -> E + T | T
     T -> T * F | F
     F -> (E) | a

     (a+a)*(a+a) \element L(G) ?

Why use this complicated grammar? 
  
  Because unlike the other one, the ()s clear up ambiguity

###Sentential Forms
Sentential forms of a grammar G = (N,E,P,S) are recursively defined as:
  1. S is a S.F.
  2. IF aBr is a S.F. and B->D in P
   - then aDr is a S.F.

####Example

   E (is sentential)
   T (derived from E, also sentential form)
   F (2 step sentential form)
   T * (E) (sentential form)
   E * T (not sentential form, can't generate)

###Sentence
A sentential form consits of only terminal symbols

###Language
Language generated by grammar G = (N,E,P,S), is denoted by L(G) is:
  
    {x \element E* | x is a sentence fo G}
